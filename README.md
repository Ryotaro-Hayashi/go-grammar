# go-grammar

パッケージの仕組み  
エイリアスの意味

Qiita記事①
https://qiita.com/k-penguin-sato/items/1d0e1c6b4bf937996cd3

- 頭文字を大文字にすると外部パッケージから参照できる（外部パッケージから参照するものは頭文字が大文字）
- 関数内ではvarによる変数の宣言を「:」で省略できる
- <要基本型の違い>
- 型変換を行うときは変数を括弧で囲んで手前に型名を書く
- 定数は関数内でも「:」で宣言できない

Qiita記事②
https://qiita.com/k-penguin-sato/items/31b45fd3914797b654f0

- for文の初期化ステートメントと後処理ステートメントは省略可
- if文の条件式の手前で, スコープ内のみで有効なステートメントを書ける
- 遅延処理deferに渡した関数は呼び出し元の関数の終わりまで遅延される
- 複数のdeferはスタックされる

Qiita記事③
https://qiita.com/k-penguin-sato/items/62dfe0f93f56e4bf9157
https://qiita.com/Sekky0905/items/447efa04a95e3fec217f
https://qiita.com/kotaonaga/items/4a93ec40718c279154f5

- 初期値を与える場合は, 明示的に「*int」を付ける必要はない（変数で明示的に付ける必要がないのと同様）
- 文字列はシングルクオーテーションで定義できない（コード書いてて発見）
- ポインタにするときは「&変数」, ポインタ型変数の値を取り出すには「*ポインタ型変数」
- 関数の引数に値を渡すとコピーされる（渡す前のポインターと渡したあとの関数内でのポインターは異なる）
- 変数に代入するときもコピーされる（値渡し）
- intのポインタはPrintlnで普通に出力できるが, 構造体のポインタは「%p」などでフォーマット指定しないと「&構造体名」で出力される